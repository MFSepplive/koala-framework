"use strict";

var ConstDependency = require("webpack/lib/dependencies/ConstDependency");
var NullFactory = require("webpack/lib/NullFactory");
var ParserHelpers = require("webpack/lib/ParserHelpers");
var Parser = require("webpack/lib/Parser");

const parseTrlCalls = require('./parse-trl-calls')

class TrlPlugin {

    constructor(options) {
        this.languages = options.languages;
        this.webCodeLanguage = options.webCodeLanguage;
        this.translations = options.translations;
        this.uniquePrefix = options.uniquePrefix;
    }

    apply(compiler) {

        compiler.plugin("compilation", (compilation, params) => {
            compilation.dependencyFactories.set(ConstDependency, new NullFactory());
            compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());

            params.normalModuleFactory.plugin("parser", (parser, parserOptions) => {

                parser.plugin(["call __trl", "call __trlc", "call __trlp", "call __trlcp",
                    "call __trlKwf", "call __trlcKwf", "call __trlpKwf", "call __trlcpKwf"], (expr) => {

                    const trlStrings = parseTrlCalls(expr, parser);
                    if (trlStrings) {

                        if (!parser.state.module.__kwfTrlStrings) parser.state.module.__kwfTrlStrings = [];
                        parser.state.module.__kwfTrlStrings = parser.state.module.__kwfTrlStrings.concat(trlStrings);

                        let trlFunction = expr.callee.name.substr(2);

                        //replace function call
                        var dep = new ConstDependency("__kwfTrl."+trlFunction, expr.callee.range);
                        dep.loc = expr.callee.loc;
                        parser.state.current.addDependency(dep);

                        var expression = "require('kwf/commonjs/trl')";
                        var nameIdentifier = "__kwfTrl";
                        ParserHelpers.addParsedVariableToModule(parser, nameIdentifier, expression);
                    }
                });
            });


            params.normalModuleFactory.plugin("parser", (parser, parserOptions) => {
                parser.plugin("program", (ast) => {
                    if (parser.state.module.kwfParseRaw && !parser.state.kwfParsingRaw) {
                        let rawSource = ast.body[0].expression.right.value;
                        parser.state.module.kwfRawSource = rawSource;
                    }
                });
            });

            let scriptLoaderResources = [];
            compilation.plugin('build-module', function(module) {
                if (module.rawRequest && module.rawRequest.match(/^script-loader!/)) {
                    scriptLoaderResources.push(module.resource);
                }
                if (module.rawRequest && module.rawRequest.match(/^!![^!]*raw-loader[^!]*!/) && scriptLoaderResources.indexOf(module.resource) != -1) {
                    module.kwfParseRaw = true;
                }
            });

            let trlParser = new Parser();

            trlParser.plugin(["call trl", "call trlc", "call trlp", "call trlcp",
                "call trlKwf", "call trlcKwf", "call trlpKwf", "call trlcpKwf"], (expr) => {

                const trlStrings = parseTrlCalls(expr, trlParser);
                if (trlStrings) {
                    if (!trlParser.state.module.__kwfTrlStrings) trlParser.state.module.__kwfTrlStrings = [];
                    trlParser.state.module.__kwfTrlStrings = trlParser.state.module.__kwfTrlStrings.concat(trlStrings);
                }
            });


            compilation.plugin('succeed-module', function(module) {
                if (module.kwfRawSource) {
                    //re-parse raw source for trl

                    trlParser.parse(module.kwfRawSource, {
                        current: module,
                        module: module,
                        compilation: compilation,
                        kwfParsingRaw: true,
                        options: {}
                    });
                }
            });
        });



        let lookupTranslation = function(source, lang, trl) {
            const context = trl.context;
            const text = trl.text;
            const plural = trl.plural;
            if (this.translations[source] && this.translations[source][lang] && this.translations[source][lang][context]) {
                let translationItem;
                let translations = this.translations[source][lang][context];
                for (let i in translations) {
                    if (plural) {
                        if (translations[i].msgid == text && translations[i].msgid_plural == plural) {
                            return translations[i].msgstr;
                        }
                    } else {
                        if (translations[i].msgid == text) {
                            return translations[i].msgstr.join("\n");
                        }
                    }
                }
            }
            return null;
        }.bind(this);

        var extractTrlDataFromChunk = function(chunk, lang, source) {
            let data = {};
            if (source == 'kwf' && lang == 'en') {
                return data;
            }
            if (source == 'web' && lang == this.webCodeLanguage) {
                return data;
            }
            chunk.modules.forEach((module) => {
                //console.log(module.request, module.__kwfTrlStrings);
                if (module.__kwfTrlStrings) {
                    module.__kwfTrlStrings.forEach(i => {
                        if (i.source == source) {
                            let translated = lookupTranslation(source, lang, i);
                            if (translated) {
                                let index = i.text;
                                if (i.context) index = i.context + '__' + index;
                                if (i.plural) index += '--' + i.plural;
                                data[index] = translated;
                            }
                        }
                    });
                }

                module.blocks.forEach((block) => {
                    if (block.chunks) {
                        block.chunks.forEach((c) => {
                            var blockData = extractTrlDataFromChunk(c, lang, source);
                            Object.assign(data, blockData);
                        });
                    }
                });
            });
            return data;
        }.bind(this);

        compiler.plugin('emit', (compilation, callback) => {
            let asyncChunks = [];
            compilation.chunks.forEach((chunk) => {
                let data = {};
                chunk.modules.forEach(function (module) {
                    module.blocks.forEach((block) => {
                        if (block.chunks) {
                            block.chunks.forEach((c) => {
                                asyncChunks.push(c);
                            });
                        }
                    });
                });
            });

            if (compilation.chunks) {
                compilation.chunks.forEach((chunk) => {
                    if (asyncChunks.indexOf(chunk) == -1) {
                        this.languages.forEach((lang) => {

                            const trlDataPrefix = this.uniquePrefix ? this.uniquePrefix+'-' : '';

                            let html = '';
                            let data = extractTrlDataFromChunk(chunk, lang, 'web');
                            if (Object.keys(data).length) {
                                html += 'window[\''+trlDataPrefix+'kwfTrlData\'].push({source: "web", data: ' + JSON.stringify(data) + '});\n';
                            }

                            data = extractTrlDataFromChunk(chunk, lang, 'kwf');
                            if (Object.keys(data).length) {
                                html += 'window[\''+trlDataPrefix+'kwfTrlData\'].push({source: "kwf", data: ' + JSON.stringify(data) + '});\n';
                            }
                            if (html) {
                                html = 'window[\''+trlDataPrefix+'kwfTrlData\'] = window[\''+trlDataPrefix+'kwfTrlData\'] || [];\n' + html;
                                compilation.assets[lang + '.' + chunk.files[0]] = {
                                    source: function () {
                                        return html;
                                    },
                                    size: function () {
                                        return html.length;
                                    }
                                };
                            }
                        });
                    }

                });
            }
            callback();
        });

    }
}
module.exports = TrlPlugin;
